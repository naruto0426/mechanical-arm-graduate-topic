CH341的串口方式支持WINDOWS 98/ME/2000/XP/Vista/Linux，提供相关驱动程序，
CH341的USB转串口支持大多数常用的串口监控及调试工具程序。

驱动安装方法：
1. 标准INF文件安装方法
    WINDOWS提示找到新硬件，指定驱动程序所在目录DRIVER，自动安装驱动，
    如果WINDOWS没有提示找到新硬件，那么在设备管理器的硬件列表中，
    选择带问号的USB设备，更新驱动程序并指定目录。
2. 使用驱动程序安装工具
    直接使用CH341SER.EXE安装包，可以安装/升级/卸载驱动程序，
    该方法更适用于最终用户。

CH341串口使用方法：
    CH341实现USB转串口，在逻辑功能方面的使用方法与普通计算机串口相同。
    与普通计算机串口的区别：
      CH341提供的是仿真串口，所以不支持串口本身的纯硬件操作，例如I/O操作，
      普通计算机串口是静态设备，而CH341串口是动态设备，理论上随时会断开，
      CH341的附加功能（下面有介绍）：读取外部串行EEPROM，支持更高波特率。
    提供“模块调试”工具，启动后将“类型”选择为“手工输入发送”，
      打开串口后就可以用于CH341串口或者普通串口的输入输出监控及收发调试。

注意事项：
    CH341串口是即插即用的USB设备，正在使用CH341串口进行数据传输的过程中，
    不可以将其断开（断开是指从USB插座中取出CH341或者关闭CH341的电源），
    也就是说，必须在应用程序关闭该串口后，CH341串口才可以从USB插座中拔出。

    如果在应用程序使用CH341串口的过程中，CH341串口设备从USB插座中断开，
    那么应用程序应该尽快关闭CH341串口并退出（关闭及退出可能需要数秒时间）。

    如果在CH341串口通讯过程中发生错误，极有可能是CH341串口已经物理断开，
    所以在检测到错误后建议关闭CH341串口，稍等两秒后再重新打开串口通讯。

    采用设备事件通知的方法可以及时了解CH341串口设备的连接与断开，
    从而使串口应用程序能够及时打开和关闭CH341串口。
    串口动态链接库CH341PT.DLL提供了API，可以监视CH341串口插拔事件，
    可以搜索和识别CH341串口等，具体需参考CH341PT.H文件。

    如果通讯波特率较高，建议设置较大的缓冲区，尤其在WINDOWS 98/ME下，
    线程调度能力和USB实时性都比WINDOWS 2000/XP差，如果串口接收缓冲区较小，
    那么在通讯波特率较高时，接收大量数据会导致串口缓冲区溢出而丢弃数据。

    由于底层的USB是将多个字节组成数据包后安插到各个1mS帧中进行传输，
    所以有可能将串口收发的紧靠着的两个字节实际分割在两个USB数据包甚至
    两个USB帧中，在最坏情况下这两个字节在时间上有可能相隔1mS甚至2mS。

*******************************************************************************

如果需要速率控制（流控制），建议不要使用MODEM信号控制，因为其效率较低，
建议用CH341的TEN#和RDY#实现纯硬件的速率控制，其中TEN#为输入，RDY#为输出，
当TEN#输入为低电平时允许CH341从串口发送数据，高电平时CH341将暂停发送数据，
当RDY#输出为低电平时说明CH341可以接收串口数据，高电平说明CH341正忙而不能接收。

如果计算机及单片机不忙，或者波特率在115200bps以下时，通常不需要速率控制，
如果波特率再高或者计算机及单片机较忙，才需要考虑采用TEN#和RDY#进行速率控制。

CH341用于串口时，其硬件最简单时只需要三根线：GND，TXD，RXD，
可以直接与单片机相连，波特率支持从50bps到2Mbps，例如MCS51单片机：
   CH341引脚        MCS51单片机引脚
      GND     <=>       GND
      TXD     <=>       RXD
      RXD     <=>       TXD
      TEN接GND

与单片机相连时，通常将CH341的TEN#引脚直接接地，总是允许CH341发送数据，
如果预算单片机可能会来不及接收串口数据，那么应该将TEN#连接到单片机的I/O引脚，
当单片机不忙时，由单片机将CH341的TEN#置为低电平，允许CH341从串口发出数据，
当单片机较忙时，由单片机将CH341的TEN#置为高电平，CH341将暂停从串口发出数据

CH341的TNOW引脚是收发状态，可以用于半双工通讯的收发切换，例如RS485的收发切换。

*******************************************************************************
如何识别CH341串口，如何知道CH341的串口号COM?

在首次安装CH341串口驱动时，CH341串口号由WINDOWS自动分配（通常从COM3开始分配），
安装完成后可以在设备管理中点其属性修改串口号。由于应用程序事先无法知道CH341的
实际串口号，所以必须使用一些特殊方法识别出CH341串口，然后才能使用。

在WINDOWS 98/ME系统下，CH341串口号与当前硬件资源配置有关，默认为自动分配资源，
  从而排在当前实际串口号之后，可以在串口属性中选择CH341资源配置来指定串口号。
在WINDOWS 2000/XP系统下，CH341串口号与当前所在USB端口有关，由首次安装时分配，
  WINDOWS记忆各USB端口CH341的串口号，可以在串口属性中通过高级选项指定串口号。

比较简单但很费事的方法是，在首次安装CH341串口后，用程序修改注册表或者点其属性，
人为将CH341的串口号修改为COM5，避开常用的COM1到COM4，该方法简单但是有可能冲突。

常规的识别方法是采用软件查询方法：
   尝试以串口名称逐个打开，打开成功后通过该串口收发特殊字符串识别CH341串口，
   该方法是从“COM1”开始，接着“COM2”逐个尝试打开串口。如果某个串口打开成功，
   那么在300bps波特率下向该串口发出特殊字符串“CH341Ser?”，如果在约200毫秒之内
   收到应答字符“W”，那么该串口就是当前已经连接的CH341串口。软件设计方法是：
   从COM1开始依次打开每个串口，如果打开串口失败则跳过（串口不存在或正在使用），
   如果打开成功则设置该串口波特率为300，然后向该串口写入ASCII字符串"$CH341Ser?"，
   注意大小写，共10个字符一次写入，如果该串口是普通串口，那么通常没有任何返回，
   如果该串口是CH341串口，那么应用程序将能接收到一个ASCII字符"W"，以此识别CH341。
   例如，用串口监控/调试工具软件演示：
     将串口的波特率选择为300bps（有些工具软件在选择波特率后必须重新打开串口），
     发出特征字符串，为10个ASCII码数据： $CH341Ser?
     发送成功后，普通串口没有返回，而CH341串口将返回1个ASCII码： W

建议使用CH341PT.DLL动态库，应用程序可以直接调用DLL中相应的API识别CH341串口，
   识别速度快，效率高。注意，CH341PT.DLL在INF中定义为可选安装，默认是安装的

*******************************************************************************
关于读取外部串行EEPROM

CH341可以外接I2C接口的器件，例如常用的24系列串行非易失存储器EEPROM，
支持24C01A，24C02，24C04，24C08，24C16等，以及与之时序兼容的器件，
24系列EEPROM既可以用于配置CH341，也可以用于断电期间保存重要数据。
例如保存产品序列号等识别信息，应用程序可以读出用于识别产品功能等。
如果需要支持24C64、24C256、24C512以及更大容量的EEPROM，请参考CH341评估板资料。

应用程序可以按串口方式读写CH341所连接的24系列EEPROM，方法是：
  设置CH341串口波特率为300，然后以4字节为一组的命令包写串口，
  命令包的首字节必须是@，地址符，对应的十六进制数为40H，
  命令包的第二字节是24系列EEPROM的设备地址，位0是方向标志，0为写，1为读，
  命令包的第三字节是24系列EEPROM的单元地址，
  命令包的第四字节是准备写入24系列EEPROM的一个数据，如果是读操作则指定为00H，
  如果是写操作，那么命令发送成功就说明写成功，对于EEPROM还要延时10mS才能下一个操作，
  如果是读操作，那么命令发送成功后，可以从串口接收到一个字节的数据，就是读出的数据

例如，CH341连接24C0X，A2=A1=A0=GND，将仿真串口的波特率选择为300bps，
可以用串口监控/调试工具软件演示：
1、发出命令包，为4个十六进制数据： 40 A1 01 00
   将24C0X中地址为01H的数据读出，可以从串口接收到一个字节的数据
2、发出命令包，为4个十六进制数据： 40 A0 2A 69
   将一个字节的数据69H写到24C0X中地址为2AH的单元，通常等待10mS后才能进行下一个操作
3、发出命令包，为4个十六进制数据： 40 A5 E7 00
   将24C0X中地址为02E7H的数据读出，可以从串口接收到一个字节的数据
   注意，只有24C08和24C16中有地址为02E7H的数据单元

*******************************************************************************
关于支持非标准波特率或者更高通讯波特率

对于一些非标准波特率或者常规方法无法设置的高速波持率，CH341驱动程序提供特殊方法，
应用程序可以按串口写数据的方式间接设置CH341的串口通讯波特率，方法是：
  设置CH341串口波特率为300，然后以ASCII码字符串的命令包写串口，
  命令包的首字节必须是#，井字符，对应的十六进制数为23H，
  命令包的中间为不超过7个数字表示的波特率，例如字符串9600或者921600等，
  命令包的尾字节必须是_，下划线，对应的十六进制数为5FH，
  也就是说，将要设置的波特率以字符串的形式置于#字符和_字符之间，作为一个命令包，
  在300bps下发送到CH341的串口，那么将被CH341驱动程序解释为修改CH341的波特率，
  而不会被作为数据从串口真正发出，当该操作成功返回后，
  CH341实际工作于指定的新波特率，当然，计算机系统及串口控件仍然以为是工作于300bps，
  如果需要再次以这种方法改变波特率，那么首先要用常规方法将CH341的波特率置为300bps。

例如，用串口监控/调试工具软件演示：
1、将CH341串口的波特率选择为300bps（有些工具软件在选择波特率后必须重新打开串口），
   发出字符串命令包，为6个ASCII码数据： #9600_
   发送成功后，CH341将实际工作于9600bps
2、将CH341串口的波特率选择为300bps（有些工具软件在选择波特率后必须重新打开串口），
   发出字符串命令包，为8个ASCII码数据： #460800_
   发送成功后，CH341将实际工作于460800bps
3、将CH341串口的波特率选择为300bps（有些工具软件在选择波特率后必须重新打开串口），
   发出字符串命令包，为9个ASCII码数据： #1000000_
   发送成功后，CH341将实际工作于1000000bps

CH341串口支持50bps到2Mbps的波特率，当应用程序请求CH341改变串口通讯波特率时，
CH341驱动程序将波特率换算为波特率除数，然后修改CH341芯片内部的波特率除数寄存器，
所以设置CH341串口的通讯波特率实际上是设置CH341芯片内部的波特率除数寄存器，
由于CH341内部的串口基准位时钟为48/8=6MHz（或12MHz），并且波特率除数只支持整数，
所以在指定波特率时，应该考虑实际换算误差，在波特率大于19200bps时的计算方法是：
    X = 6000000 除以波特率后的值
    Y = X 四舍五入后的值
    误差 = ( Y - X ) / X

以下为CH341支持的常用波特率，未注明的基准位时钟为6MHz，未注明的误差小于0.16%
    921600 (12MHz),   460800,   307200 (12MHz),
    230400,  153600,  128000 (0.27%),    115200,
    76800,   57600,   56000,    38400,   33600,
    28800,   19200,   14400,    9600,    7200,
    4800,    3600,    2400,     1800,    1200,
    900,     600,     300,      150,     134.5,
    110,     100,     75,       50,      2000000,
    1500000, 1200000, 1000000,  750000,  500000,
    375000,  250000,  200000,   187500,  100000,
    93750,   75000,   50000,    25000,   10000
其它波特率只要误差小于2.5%，CH341都可以支持，计算误差时要考虑两端的误差之和。
但是为了可靠进行通讯，建议不要使用误差大于1%的波特率。

*******************************************************************************
USB设备驱动程序与仿真串口驱动程序

CH341串口硬件的默认驱动程序是仿真串口驱动程序，
即在计算机端多出一个串口，并且在下位机端CH341芯片也使用串口通讯。
计算机端应用程序通过操作仿真串口实现USB数据传输，其用法与普通串口相同。

如果不希望在计算机端仿真为串口，那么可以使用USB设备驱动程序，
即在计算机端多出一个USB设备，但是在下位机端CH341芯片仍然使用串口通讯。
计算机端应用程序通过调用DLL提供的API实现USB数据传输,
其用法与CH341并口、CH372、CH375类似，可以参考相关的应用程序的源程序。

CH341串口硬件的USB设备驱动与并口硬件的USB设备驱动CH341PAR完全相同，
区别仅在于驱动安装信息文件INF中的PID不同（参考CH341PAR的INF中的注释行说明）。

*******************************************************************************
